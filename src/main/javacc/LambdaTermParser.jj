/**
 * JavaCC file
 */


options {
  JDK_VERSION = "1.5";
  STATIC = false;
  LOOKAHEAD=2;
  //FORCE_LA_CHECK=true;
}
PARSER_BEGIN(LambdaTermParser)
package de.saar.penguin.irtg.algebra.lambda;

import java.io.ByteArrayInputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.*;
import java.io.*;


import de.saar.basic.Pair;

/**
 * Parser for Geo880-style lambda terms.
 * @author Alexander Koller
 */
public class LambdaTermParser {
    private static LambdaTermParser parser = new LambdaTermParser(new ByteArrayInputStream(new byte[]{}));


    public static LambdaTerm parse(Reader reader) throws ParseException {
        parser = new LambdaTermParser(new ByteArrayInputStream(new byte[]{}));
        parser.ReInit(reader);

	return parser.lambdaterm();
    }
}
PARSER_END(LambdaTermParser)

SKIP : { " " | "\t" | "\r" | "\n" }

TOKEN :
{
    <LAMBDA: "lambda"> |
    <ARGMAX: "argmax"> |
    <ARGMIN: "argmin"> |
    <AND: "and"> |
    <EXISTS: "exists"> |
    < NAME:     ["a"-"z","A"-"Z","_"] (["a"-"z","A"-"Z","_", "'", "<", ">", "+", "-", "0"-"9", "*", "."] )* > |
    < VARIABLE: "$" (["0"-"9","a"-"z","A"-"Z","_"])* > |
    <LINE_END_COMMENT: "//" (~["\n"])* >
}


LambdaTerm lambdaterm() : {
    LambdaTerm sub;
}{
    (sub = constant() | sub = variable() | sub = apply() | sub = lambda()
     | sub = argmin() | sub = argmax() | sub = exists() | sub = conj()
    ) {
        return sub;
    }
}

LambdaTerm constant() : {
    Pair<String,String> name;
}{
    name = nameWithType() { return LambdaTerm.constant(name.left, name.right); }
}

LambdaTerm variable() : {
    String name;
}{
    name = <VARIABLE>.image { return LambdaTerm.variable(name); }
}

LambdaTerm apply() : {
    LambdaTerm sub1;
    List<LambdaTerm> arguments;
}{
    "(" sub1=lambdaterm() arguments = listOfTerms() ")" {
        return LambdaTerm.apply(sub1, arguments);
    }
}

LambdaTerm lambda() : {
    String varname;
    LambdaTerm sub;
}{
    "(" <LAMBDA> varname=<VARIABLE>.image sub=lambdaterm() ")" {
        return LambdaTerm.lambda(varname, sub);
    }
}

LambdaTerm conj() : {
    List<LambdaTerm> subs;
}{
    "(" <AND> subs = listOfTerms() ")" {
        return LambdaTerm.conj(subs);
    }
}

LambdaTerm argmax() : {
    String varname;
    LambdaTerm sub1, sub2;
}{
    "(" <ARGMAX> varname=<VARIABLE>.image sub1=lambdaterm() sub2=lambdaterm() ")" {
        return LambdaTerm.argmax(varname, sub1, sub2);
    }
}

LambdaTerm argmin() : {
    String varname;
    LambdaTerm sub1, sub2;
}{
    "(" <ARGMIN> varname=<VARIABLE>.image sub1=lambdaterm() sub2=lambdaterm() ")" {
        return LambdaTerm.argmin(varname, sub1, sub2);
    }
}

LambdaTerm exists() : {
    String varname;
    LambdaTerm sub;
}{
    "(" <EXISTS> varname=<VARIABLE>.image sub=lambdaterm() ")" {
        return LambdaTerm.exists(varname, sub);
    }
}

Pair<String,String> nameWithType() : {
    String name, type;
}{
    name = <NAME>.image ":" type = <NAME>.image {
        return new Pair<String,String>(name,type);
    }
}

List<LambdaTerm> listOfTerms() : {
    List<LambdaTerm> ret = new ArrayList<LambdaTerm>();
    LambdaTerm sub;
}{
    ( sub = lambdaterm() { ret.add(sub); }) * { return ret; }
}

